var onselect = function(rows, node, pstore) {
  // The followincg series of provenance queries kind of sucks
  var tableoutput = pstore.children(node, 'output');
  var tablesource = pstore.backward(tableoutput, 'table');
  var tablesinks = pstore.forward(tablesource, 'table');
  tablesinks = tablesinks.filter(function(t) { 
    return pstore.parents(t, 'output').length > 0;
  })
  var allviews = tablesinks.map(function(n) {
    return pstore.parents(n, 'output') 
  });
  var views = allviews.filter(function(arr) { 
    return arr.length > 0;
  })
  views = views.map(_.first);
  views = views.filter(function(v) {
    return v.id != node.id;
  });
  var outputs = views.map(function(view) {
    return pstore.children(view, 'output')[0]
  });

  var ids = pstore.ids(rows);
  var svgs = [];
  _.each(outputs, function(output) {
    var allids = _.union(output.map(function(row){
      return row.prov()
    }))
    output.each(function(row) {
      var el = d3.select(row.get('el'));
      if (_.intersection(row.prov(), ids).length > 0) {
        el.attr('fill', d3.rgb(row.get('fill')).darker(2));
      } else {
        el.attr('fill', row.get('fill'));
      }
    })
  })

};
var outputs = {};
var specs = [
  {
  layers: [
  { geom: 'point' }
  ],
  aes: {
    x: 'd',
    y: 'e',
    color: 't'
  },
  facets: {
    x: 'g',
    y: 'f'
  }
},
  {
    "layers": [
      {
        "geom": 'rect',
        "stat": "bin",
        scales: {color: 'color'}
      }
    ], 

    "aes": {
      "x": "d", 
      "y": "e"
    }
  }
]

/*
{
  "layers": [
    {
      "geom": {
        "type": "bin2d", 
        "aes": {
          "color": "sum"
        }
      }, 
      "stat": "bin2d"
    }
  ], 
  "aes": {
    "x": "d", 
    "y": "e", 
    "z": 1
  }, 
  "facets": {
    "x": "g"
  }
},
  {
    layers: [
      { 
        geom: "point",
        pos: [ 
          {
            type: 'bin2d',
            n: 10
          }, 'jitter']
      }
    ]
    ,aes: {x: 'd', y: 'e', r: 'g', color: "g"}
    ,scales: {
      fill: "color",
      r: { range: [2, 10] }
    }

  }
]
*/


;(function (specs) {
  var gendata = function(npts) {
    if (!npts || npts === undefined) { npts = 500; }
    Math.seedrandom("zero");
    var gauss = science.stats.distribution.gaussian();
    var pts = _.map(_.range(0, npts), function(d) {
      g = d % 3//Math.floor(Math.random() * 3) + 1;
      f = Math.floor(Math.random() * 3);
      t = Math.floor(Math.random() * 2);
      gauss.variance(d * 30.0 / npts);
      d = Math.floor(d/3)
      e = ((d + gauss())*(2+Math.sin(d/50))) * (g) - (d)
      //e = d

      return {d: d, e: e,  g: g, f:f, t:t};
    });
    return gg.data.Table.fromArray(pts, null, 'row')
  };
  var ex   = function () {
    $("#examples").empty();
    return d3.select('#examples');
  };

  var bigdata = [];

  var render = function(spec, svg) {
    spec = _.clone(spec);
    spec.data = bigdata;
    spec.on = {
      select: function(geoms, table, prov) {
        onselect(geoms, table, prov);
      }
    }
    var plot = gg(spec);
    plot.render(svg);
    plot.on("output", function(nodeid, port, data) {
      outputs[[nodeid, port]] = data;
    });
    plot.on("done", function(debug) {
      return;
      var pstore = prov.Prov.get()
      var wfnodes = pstore.nodes(function(n) { return gg.util.Util.isType(n, gg.wf.Node); })
      var geoms = wfnodes.filter(function(n) { return pstore.children(n, 'wf').length == 0; } )
      var sources = pstore.backward(geoms, 'wf');
      var views = pstore.forward(sources, 'wf');
      var outputs = pstore.forward(views, 'output');

      _.each(wfnodes, function(n) {
        var output = pstore.children(n, 'output')[0];
        console.log([n.name, 
          output.id,
          (gg.util.Util.isType(n, gg.wf.Exec) || gg.util.Util.isType(n, gg.wf.Barrier)), pstore.children(output, 'table')])
      })
    })

  }


  // This file contains the code to define the graphics and then
  // renders them using data randomly generated by data.js.

  $(document).ready(function() {

    var svg = ex();
    bigdata = gendata();
    _.each(specs, function(spec) {
      render(spec, svg.append('div'))
    });
  });
})(specs);

